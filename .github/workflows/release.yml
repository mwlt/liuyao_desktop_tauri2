name: "å‘å¸ƒæ–°ç‰ˆæœ¬"

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'ç‰ˆæœ¬å·ï¼ˆä¾‹å¦‚: 2.6.9ï¼‰'
        required: true
        type: string
      draft:
        description: 'æ˜¯å¦åˆ›å»ºä¸ºè‰ç¨¿'
        required: false
        type: boolean
        default: true
      prerelease:
        description: 'æ˜¯å¦ä¸ºé¢„å‘å¸ƒç‰ˆæœ¬'
        required: false
        type: boolean
        default: false

jobs:
  # åˆ›å»º Release
  create-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.id }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Determine version
        id: get-version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="v${{ github.event.inputs.version }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_draft=${{ github.event.inputs.draft }}" >> $GITHUB_OUTPUT
            echo "is_prerelease=${{ github.event.inputs.prerelease }}" >> $GITHUB_OUTPUT
          else
            VERSION="${{ github.ref_name }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_draft=true" >> $GITHUB_OUTPUT
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi
          echo "ğŸ“Œ ç‰ˆæœ¬å·: $VERSION"
        shell: bash
      
      - name: Create Release
        id: create-release
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # å®šä¹‰ Release å†…å®¹
          RELEASE_BODY=$(cat << 'EOF'
          ## ğŸ‰ å…­çˆ»æ’ç›˜ä¸ç ”ç©¶ ${{ steps.get-version.outputs.version }} å‘å¸ƒ

          ### ğŸ“¦ æ”¯æŒå¹³å°
          - **Windows**: MSI å®‰è£…åŒ…ã€NSIS å®‰è£…ç¨‹åºã€ä¾¿æºç‰ˆ
          - **macOS**: Intel ä¸“ç”¨ç‰ˆã€Apple Silicon ä¸“ç”¨ç‰ˆ (DMGæ ¼å¼)
          - **Linux**: DEBåŒ…ã€RPMåŒ…ã€AppImage ä¾¿æºç‰ˆ

          ### ğŸ”½ ä¸‹è½½è¯´æ˜
          - **Windows ç”¨æˆ·**: 
            - å®‰è£…ç‰ˆï¼šä¸‹è½½ `.msi` æˆ– `.exe` æ–‡ä»¶
            - ä¾¿æºç‰ˆï¼šä¸‹è½½ `.zip` æ–‡ä»¶
          - **macOS ç”¨æˆ·**: 
            - Intel Mac: ä¸‹è½½åŒ…å« `intel` çš„ `.dmg` æ–‡ä»¶
            - Apple Silicon Mac: ä¸‹è½½åŒ…å« `apple_silicon` çš„ `.dmg` æ–‡ä»¶  
          - **Linux ç”¨æˆ·**: 
            - Ubuntu/Debian: ä¸‹è½½ `.deb` æ–‡ä»¶
            - RHEL/CentOS/Fedora: ä¸‹è½½ `.rpm` æ–‡ä»¶
            - å…¶ä»–å‘è¡Œç‰ˆ: ä¸‹è½½ `.AppImage` æ–‡ä»¶
          EOF
          )
          
          # åˆ›å»º Release
          RESPONSE=$(gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/releases \
            -f tag_name='${{ steps.get-version.outputs.version }}' \
            -f name='å…­çˆ»æ’ç›˜ä¸ç ”ç©¶ ${{ steps.get-version.outputs.version }}' \
            -f body="$RELEASE_BODY" \
            -F draft=${{ steps.get-version.outputs.is_draft == 'true' }} \
            -F prerelease=${{ steps.get-version.outputs.is_prerelease == 'true' }})
          
          # æå– release ID å’Œ upload URL
          RELEASE_ID=$(echo "$RESPONSE" | jq -r '.id')
          UPLOAD_URL=$(echo "$RESPONSE" | jq -r '.upload_url')
          
          # è®¾ç½®è¾“å‡º
          echo "id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "upload_url=$UPLOAD_URL" >> $GITHUB_OUTPUT
          
          echo "âœ… Release åˆ›å»ºæˆåŠŸï¼"
          echo "ğŸ“Œ Release ID: $RELEASE_ID"
          echo "ğŸ“¤ Upload URL: $UPLOAD_URL"

  # æ„å»ºå¹¶ä¸Šä¼ 
  build-and-upload:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows 64ä½
          - platform: windows-latest
            os: windows
            arch: x86_64
            rust-target: x86_64-pc-windows-msvc
            artifact-name: windows-x64

          # Linux 64ä½
          - platform: ubuntu-22.04
            os: linux
            arch: x86_64
            rust-target: x86_64-unknown-linux-gnu
            artifact-name: linux-x64

          # macOS Intel ç‰ˆæœ¬
          - platform: macos-latest
            os: macos
            arch: x86_64
            rust-target: x86_64-apple-darwin
            artifact-name: macos-intel

          # macOS Apple Silicon ç‰ˆæœ¬
          - platform: macos-latest
            os: macos
            arch: aarch64
            rust-target: aarch64-apple-darwin
            artifact-name: macos-arm64

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.0-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8
          run_install: false

      - name: Install frontend dependencies
        run: pnpm install

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust-target }}

      # æ„å»º Tauri åº”ç”¨
      - name: Build Tauri app
        run: pnpm tauri build --target ${{ matrix.rust-target }}

      # é‡å‘½åæ„å»ºäº§ç‰©
      - name: Rename artifacts
        shell: bash
        run: |
          echo "ğŸ”„ å¼€å§‹é‡å‘½å ${{ matrix.os }} æ„å»ºäº§ç‰©..."
          
          # å®šä¹‰ç›®æ ‡ç›®å½•
          target_dir="src-tauri/target/${{ matrix.rust-target }}/release/bundle"
          
          # è®¾ç½®æ“ä½œç³»ç»Ÿå’Œæ¶æ„åç¼€
          case "${{ matrix.os }}" in
            "windows")
              os_suffix="_windows_x64"
              ;;
            "linux")
              os_suffix="_linux_x64"
              ;;
            "macos")
              if [ "${{ matrix.arch }}" = "x86_64" ]; then
                os_suffix="_macos_intel"
              else
                os_suffix="_macos_apple_silicon"
              fi
              ;;
          esac
          
          echo "ğŸ“ ä½¿ç”¨åç¼€: $os_suffix"
          
          # Windows äº§ç‰©é‡å‘½å
          if [ "${{ matrix.os }}" = "windows" ]; then
            # MSI æ–‡ä»¶
            if [ -d "$target_dir/msi" ]; then
              cd "$target_dir/msi"
              for file in *.msi; do
                if [ -f "$file" ]; then
                  base="${file%_*}"
                  new_name="${base}${os_suffix}.msi"
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
            
            # NSIS æ–‡ä»¶
            if [ -d "$target_dir/nsis" ]; then
              cd "$target_dir/nsis"
              for file in *.exe; do
                if [ -f "$file" ]; then
                  # å¤„ç† setup.exe æ ¼å¼
                  if [[ "$file" == *-setup.exe ]]; then
                    base="${file%-setup.exe}"
                    new_name="${base}${os_suffix}-setup.exe"
                  else
                    base="${file%.exe}"
                    new_name="${base}${os_suffix}.exe"
                  fi
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
          fi
          
          # macOS äº§ç‰©é‡å‘½å
          if [ "${{ matrix.os }}" = "macos" ]; then
            # DMG æ–‡ä»¶
            if [ -d "$target_dir/dmg" ]; then
              cd "$target_dir/dmg"
              for file in *.dmg; do
                if [ -f "$file" ]; then
                  base="${file%.dmg}"
                  new_name="${base}${os_suffix}.dmg"
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
          fi
          
          # Linux äº§ç‰©é‡å‘½å
          if [ "${{ matrix.os }}" = "linux" ]; then
            # DEB æ–‡ä»¶
            if [ -d "$target_dir/deb" ]; then
              cd "$target_dir/deb"
              for file in *.deb; do
                if [ -f "$file" ]; then
                  # å¤„ç† _amd64.deb æ ¼å¼
                  if [[ "$file" == *_amd64.deb ]]; then
                    base="${file%_amd64.deb}"
                    new_name="${base}${os_suffix}.deb"
                  else
                    base="${file%.deb}"
                    new_name="${base}${os_suffix}.deb"
                  fi
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
            
            # RPM æ–‡ä»¶
            if [ -d "$target_dir/rpm" ]; then
              cd "$target_dir/rpm"
              for file in *.rpm; do
                if [ -f "$file" ]; then
                  base="${file%.rpm}"
                  new_name="${base}${os_suffix}.rpm"
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
            
            # AppImage æ–‡ä»¶
            if [ -d "$target_dir/appimage" ]; then
              cd "$target_dir/appimage"
              for file in *.AppImage; do
                if [ -f "$file" ]; then
                  # å¤„ç† _amd64.AppImage æ ¼å¼
                  if [[ "$file" == *_amd64.AppImage ]]; then
                    base="${file%_amd64.AppImage}"
                    new_name="${base}${os_suffix}.AppImage"
                  else
                    base="${file%.AppImage}"
                    new_name="${base}${os_suffix}.AppImage"
                  fi
                  mv "$file" "$new_name" 2>/dev/null || true
                  echo "âœ… é‡å‘½å: $file -> $new_name"
                fi
              done
              cd - > /dev/null
            fi
          fi
          
          echo "âœ¨ é‡å‘½åå®Œæˆï¼"

      # Windows ä¾¿æºç‰ˆæ„å»º
      - name: Build Windows Portable Version
        if: matrix.os == 'windows'
        shell: pwsh
        run: |
          cd src-tauri
          .\scripts\build-portable.ps1
          
          # é‡å‘½åä¾¿æºç‰ˆæ–‡ä»¶
          $portableDir = "target/portable"
          if (Test-Path $portableDir) {
            Get-ChildItem -Path $portableDir -Filter "*.zip" | ForEach-Object {
              $oldName = $_.Name
              if ($oldName -match "liuyao-desktop-portable-v(.+)\.zip") {
                $version = $matches[1]
                $newName = "liuyao-desktop-portable-v${version}_windows_x64.zip"
                $newPath = Join-Path $portableDir $newName
                Move-Item $_.FullName $newPath -Force
                Write-Host "âœ… ä¾¿æºç‰ˆé‡å‘½å: $oldName -> $newName"
              }
            }
          }

      # åˆ›å»º macOS APP å‹ç¼©åŒ…
      - name: Create macOS APP archive
        if: matrix.os == 'macos'
        shell: bash
        run: |
          app_dir="src-tauri/target/${{ matrix.rust-target }}/release/bundle/macos"
          if [ -d "$app_dir" ]; then
            cd "$app_dir"
            
            # è®¾ç½®æ¶æ„åç¼€
            if [ "${{ matrix.arch }}" = "x86_64" ]; then
              os_suffix="_macos_intel"
            else
              os_suffix="_macos_apple_silicon"
            fi
            
            for app in *.app; do
              if [ -d "$app" ]; then
                # è·å–åº”ç”¨åç§°ï¼ˆä¸åŒ…å« .appï¼‰
                app_name="${app%.app}"
                archive_name="${app_name}${os_suffix}.app.tar.gz"
                tar -czf "$archive_name" "$app"
                echo "âœ… åˆ›å»ºå‹ç¼©åŒ…: $archive_name"
              fi
            done
          fi

      # æ”¶é›†æ‰€æœ‰æ„å»ºäº§ç‰©
      - name: Collect artifacts
        shell: bash
        run: |
          mkdir -p artifacts
          
          # å®šä¹‰ç›®æ ‡ç›®å½•
          target_dir="src-tauri/target/${{ matrix.rust-target }}/release/bundle"
          
          # Windows äº§ç‰©
          if [ "${{ matrix.os }}" = "windows" ]; then
            # MSI
            find "$target_dir/msi" -name "*.msi" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
            # NSIS
            find "$target_dir/nsis" -name "*.exe" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
            # ä¾¿æºç‰ˆ
            find "src-tauri/target/portable" -name "*.zip" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
          fi
          
          # macOS äº§ç‰©
          if [ "${{ matrix.os }}" = "macos" ]; then
            # DMG
            find "$target_dir/dmg" -name "*.dmg" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
            # APP tar.gz
            find "$target_dir/macos" -name "*.app.tar.gz" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
          fi
          
          # Linux äº§ç‰©
          if [ "${{ matrix.os }}" = "linux" ]; then
            # DEB
            find "$target_dir/deb" -name "*.deb" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
            # RPM
            find "$target_dir/rpm" -name "*.rpm" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
            # AppImage
            find "$target_dir/appimage" -name "*.AppImage" -type f -exec cp {} artifacts/ \; 2>/dev/null || true
          fi
          
          echo "ğŸ“¦ æ”¶é›†åˆ°çš„äº§ç‰©ï¼š"
          ls -la artifacts/

      # ä¸Šä¼ äº§ç‰©åˆ° GitHub Actions Artifactsï¼ˆç”¨äºè°ƒè¯•ï¼‰
      - name: Upload artifacts to GitHub Actions
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: artifacts/*
          retention-days: 1

      # ä¸Šä¼ äº§ç‰©åˆ° Release (Windows)
      - name: Upload Release Assets (Windows)
        if: matrix.os == 'windows'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        shell: pwsh
        run: |
          $uploadUrl = "${{ needs.create-release.outputs.upload_url }}"
          $uploadUrl = $uploadUrl -replace '\{.*\}', ''
          
          Get-ChildItem -Path "artifacts" -File | ForEach-Object {
            $filename = $_.Name
            $filepath = $_.FullName
            Write-Host "ğŸ“¤ ä¸Šä¼ : $filename"
            
            # è·å– MIME ç±»å‹
            $mime = switch -Regex ($filename) {
              '\.msi$' { "application/x-msi" }
              '\.exe$' { "application/x-msdownload" }
              '\.zip$' { "application/zip" }
              default { "application/octet-stream" }
            }
            
            # ä½¿ç”¨ curl ä¸Šä¼ æ–‡ä»¶
            $headers = @{
              "Authorization" = "token $env:GITHUB_TOKEN"
              "Content-Type" = $mime
            }
            
            $uri = "${uploadUrl}?name=${filename}"
            Invoke-RestMethod -Uri $uri -Method Post -Headers $headers -InFile $filepath
          }

      # ä¸Šä¼ äº§ç‰©åˆ° Release (Unix)
      - name: Upload Release Assets (Unix)
        if: matrix.os != 'windows'
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        shell: bash
        run: |
          upload_url="${{ needs.create-release.outputs.upload_url }}"
          
          # éå† artifacts ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
          for file in artifacts/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "ğŸ“¤ ä¸Šä¼ : $filename"
              
              # è·å– MIME ç±»å‹
              case "${filename##*.}" in
                dmg) mime="application/x-apple-diskimage" ;;
                gz) mime="application/gzip" ;;
                deb) mime="application/vnd.debian.binary-package" ;;
                rpm) mime="application/x-rpm" ;;
                AppImage) mime="application/x-executable" ;;
                *) mime="application/octet-stream" ;;
              esac
              
              # ä½¿ç”¨ curl ä¸Šä¼ æ–‡ä»¶
              curl -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: $mime" \
                --data-binary "@$file" \
                "${upload_url%\{*}?name=$filename"
            fi
          done

      # å¤±è´¥æ—¶ä¸Šä¼ æ—¥å¿—
      - name: Upload build logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.artifact-name }}
          path: |
            src-tauri/target/**/build.log
            src-tauri/target/**/cargo-build.log
          if-no-files-found: ignore
          retention-days: 7